# Hugo Bouza Fernández
# Rafael Casás Lamas
# Xosé Castro González

import time
import random
from collections.abc import Callable

# Medición de tiempo
def microsegundos():
    return time.perf_counter_ns() // 1000

# Funciones de dispersión
def dispersionA(clave : str, tamTabla : int)-> int:
    n = min(8, len(clave))
    valor = ord(clave[0])
    for i in range(1, n):
        valor += ord(clave[i])
    return valor % tamTabla

def dispersionB(clave : str, tamTabla : int)-> int:
    n = min(8, len(clave))
    valor = ord(clave[0])
    for i in range(1, n):
        valor = ((valor * 32) + ord(clave[i])) # desplazamiento de 5 bits
    return valor % tamTabla # a multiplicar por 32


# EJERCICIO 1
# Tablas de dispersión abierta 
# (factor de carga aproximado de  λ = 1,0(N = 19069))
class Nodo:
    def __init__(self, clave, sinonimos):
        self.clave = clave
        self.sinonimos = sinonimos
        self.siguiente = None 

class TablaAbierta:
    def __init__(self, tam, dispersion):
        # Inicialización del vector de punteros/cabeceras
        self.tabla = [None] * tam
        self.tam = tam
        self.dispersion = dispersion

    def buscar(self, clave):
        # Busca la clave en la tabla. 
        # Devuelve:
            # tupla (str | None, int): (sinónimos o None, número de colisiones).
        # 1. Calcular el índice de dispersión
        indice = self.dispersion(clave, self.tam)
        actual = self.tabla[indice]
        comparaciones = 0
        # 2. Recorrer la lista enlazada (cubeta)
        while actual is not None:
            if actual.clave == clave:
                # Éxito: retorna los sinónimos y el número de comparaciones
                return actual.sinonimos, comparaciones
            comparaciones += 1  # ¡IMPORTANTE! Incrementar DESPUÉS de verificar pero ANTES de avanzar
            actual = actual.siguiente
            # Fracaso: retorna None y el número de comparaciones.
        return None, comparaciones

    def insertar(self, clave, sinonimos):
        # La inserción se hará por el inicio de la lista.
        # Devuelve:
            # int: el total de colisiones (comparaciones) que se produjeron 
            # al buscar la posición de inserción.
        # El segundo valor es el número de comparaciones realizadas
        pos, colisiones_al_buscar = self.buscar(clave)
        # si pos = nil entonces (No se encontró la clave, bueno para insertar)
        if pos is None:
            # i := Dispersión(Elem);
            indice = self.dispersion(clave, self.tam)
            # InsertarLista(Elem, Tabla[i]): Inserción al inicio.
            nuevo_nodo = Nodo(clave, sinonimos)
            nuevo_nodo.siguiente = self.tabla[indice]
            self.tabla[indice] = nuevo_nodo
            # Devolver las colisiones 
            return colisiones_al_buscar
        else:
            # Si ya existe, el procedimiento termina sin insertar.
            # Devolvemos 0 colisiones para la operación de inserción fallida.
            return 0

    def mostrar(self):
        # Muestra el contenido de la tabla hash.
        print("\n--- Contenido de la Tabla Hash (Dispersión Abierta) ---")
        for i in range(self.tam):
            print(f"Cubeta {i}:", end=" ")
            actual = self.tabla[i]
            if actual is None:
                print("Vacía")
            else:
                cadena_nodos = ""
                while actual is not None:
                    cadena_nodos += f"-> ({actual.clave},'{actual.sinonimos}')"
                    actual = actual.siguiente
                print(cadena_nodos.strip(" ->"))
        print("---------------------------------------------------------")


# Tablas de dispersión cerrada 
# (factor de carga aproximado de  λ = 0,5 (N = 38197)
def exploracion_lineal(pos_ini: int, intento: int)-> int:
    return pos_ini + intento

def exploracion_cuadratica(pos_ini: int, intento: int)-> int:
    return pos_ini + intento * intento

def exploracion_doble(pos_ini: int, intento: int)-> int:
    R = 10007  # Número primo menor que el tamaño de la tabla
    h2 = R - (pos_ini % R)
    return pos_ini + intento * h2

class Entrada:
    def __init__(self):
        self.ocupada = False
        self.clave = None
        self.sinonimos = None

class TablaCerrada:
    def __init__(self, tam : int, dispersion : Callable[[str, int], int],
                    resol_colisiones : Callable[[int, int], int]):
        self.tabla = [Entrada() for _ in range(tam)]
        self.tam = tam
        self.dispersion = dispersion
        self.resol_colisiones = resol_colisiones

    def buscar(self, clave : str)-> tuple[str | None, int]:
        colisiones = 0
        pos_inicial = self.dispersion(clave, self.tam)
        intento = 0
        
        while intento < self.tam:
            # Calcular posición actual según la estrategia de resolución
            pos_actual = self.resol_colisiones(pos_inicial, intento) % self.tam
            entrada = self.tabla[pos_actual]
            # Si la celda está vacía, la clave no existe
            if not entrada.ocupada:
                return None, colisiones
            # Si encontramos la clave, devolvemos los sinónimos
            if entrada.clave == clave:
                return entrada.sinonimos, colisiones
            # Colisión: incrementar contador y seguir buscando
            colisiones += 1
            intento += 1
        # Si llegamos aquí, no encontramos la clave después de revisar toda la tabla
        return None, colisiones

    def insertar(self, clave : str, sinonimos : str)-> int:
        colisiones = 0
        pos_inicial = self.dispersion(clave, self.tam)
        intento = 0
        
        while intento < self.tam:
            # Calcular posición actual según la estrategia de resolución
            pos_actual = self.resol_colisiones(pos_inicial, intento) % self.tam
            entrada = self.tabla[pos_actual]
            # Si la celda está vacía, podemos insertar aquí
            if not entrada.ocupada:
                entrada.clave = clave
                entrada.sinonimos = sinonimos
                entrada.ocupada = True
                return colisiones
            # Si la celda ya contiene la misma clave, actualizamos sinónimos
            if entrada.clave == clave:
                entrada.sinonimos = sinonimos
                return colisiones
            # Colisión con otra clave diferente
            colisiones += 1
            intento += 1
        # Si llegamos aquí, la tabla está llena
        raise Exception("Tabla llena - no se puede insertar")

    def mostrar(self):
        print(f"\n--- Tabla de dispersión cerrada (tamaño: {self.tam}) ---")
        for i in range(self.tam):
            entrada = self.tabla[i]
            if entrada.ocupada:
                print(f"{i}- [ ({entrada.clave}) ]")
            else:
                print(f"{i}- [ ]")
        print("--------------------------------------------------------")


# EJERCICIO 2
def dispersionTestTeoria(clave: str, tam_tabla: int) -> int:
    if clave in ("ANA", "JOSE", "OLGA"):
        return 7
    return 6

# Función de exploración doble para test de teoría
def exploracion_dobleTeoria(pos_ini: int, intento: int) -> int:
    R = 5  # Como en el ejemplo de teoría
    h2 = R - (pos_ini % R)
    return pos_ini + intento * h2

# Validación con ejemplo de teoría
def test_teoria():
    print("=" * 60)
    print("VALIDACIÓN CON EJEMPLO DE TEORÍA")
    print("=" * 60)
    
    # Datos de prueba del ejemplo de teoría
    datos_teoria = [
        ("ANA", "sinonimos_ANA"),
        ("LUIS", "sinonimos_LUIS"), 
        ("JOSE", "sinonimos_JOSE"),
        ("OLGA", "sinonimos_OLGA"),
        ("ROSA", "sinonimos_ROSA"),
        ("IVAN", "sinonimos_IVAN")
    ]
    
    # TEST TABLA ABIERTA
    print("\n*** TEST TABLA ABIERTA")
    tabla_abierta = TablaAbierta(11, dispersionTestTeoria)
    colisiones_totales_abierta = 0
    
    for clave, sinonimos in datos_teoria:
        colisiones = tabla_abierta.insertar(clave, sinonimos)
        colisiones_totales_abierta += colisiones
    
    print("{")
    for i in range(11):
        actual = tabla_abierta.tabla[i]
        if actual is None:
            print(f"{i}- [ ]")
        else:
            elementos = []
            while actual is not None:
                elementos.append(f"({actual.clave})")
                actual = actual.siguiente
            print(f"{i}- [ {' '.join(elementos)} ]")
    print("}")
    
    print(f"Numero total de colisiones al insertar los elementos: {colisiones_totales_abierta}")
    
    for clave, _ in datos_teoria:
        resultado, colisiones = tabla_abierta.buscar(clave)
        print(f"Al buscar: {clave}, encuentro: {clave}, colisiones: {colisiones}")
    
    resultado, colisiones = tabla_abierta.buscar("CARLOS")
    print(f"No encuentro: CARLOS, colisiones: {colisiones}")
    
    # TEST TABLA CERRADA LINEAL
    print("\n** TEST TABLA CERRADA LINEAL")
    tabla_lineal = TablaCerrada(11, dispersionTestTeoria, exploracion_lineal)
    colisiones_totales_lineal = 0
    
    for clave, sinonimos in datos_teoria:
        colisiones = tabla_lineal.insertar(clave, sinonimos)
        colisiones_totales_lineal += colisiones
    
    print("{")
    for i in range(11):
        entrada = tabla_lineal.tabla[i]
        if entrada.ocupada:
            print(f"{i}- [ ({entrada.clave}) ]")
        else:
            print(f"{i}- [ ]")
    print("}")
    
    print(f"Numero total de colisiones al insertar los elementos: {colisiones_totales_lineal}")
    
    for clave, _ in datos_teoria:
        resultado, colisiones = tabla_lineal.buscar(clave)
        print(f"Al buscar: {clave}, encuentro: {clave}, colisiones: {colisiones}")
    
    resultado, colisiones = tabla_lineal.buscar("CARLOS")
    print(f"No encuentro: CARLOS, colisiones: {colisiones}")
    
    # TEST TABLA CERRADA CUADRÁTICA
    print("\n*** TEST TABLA CERRADA CUADRÁTICA")
    tabla_cuadratica = TablaCerrada(11, dispersionTestTeoria, exploracion_cuadratica)
    colisiones_totales_cuadratica = 0
    
    for clave, sinonimos in datos_teoria:
        colisiones = tabla_cuadratica.insertar(clave, sinonimos)
        colisiones_totales_cuadratica += colisiones
    
    print("{")
    for i in range(11):
        entrada = tabla_cuadratica.tabla[i]
        if entrada.ocupada:
            print(f"{i}- [ ({entrada.clave}) ]")
        else:
            print(f"{i}- [ ]")
    print("}")
    
    print(f"Numero total de colisiones al insertar los elementos: {colisiones_totales_cuadratica}")
    
    for clave, _ in datos_teoria:
        resultado, colisiones = tabla_cuadratica.buscar(clave)
        print(f"Al buscar: {clave}, encuentro: {clave}, colisiones: {colisiones}")
    
    resultado, colisiones = tabla_cuadratica.buscar("CARLOS")
    print(f"No encuentro: CARLOS, colisiones: {colisiones}")
    
    # TEST TABLA CERRADA DOBLE
    print("\n*** TEST TABLA CERRADA DOBLE")
    tabla_doble = TablaCerrada(11, dispersionTestTeoria, exploracion_dobleTeoria)
    colisiones_totales_doble = 0
    
    for clave, sinonimos in datos_teoria:
        colisiones = tabla_doble.insertar(clave, sinonimos)
        colisiones_totales_doble += colisiones
    
    print("{")
    for i in range(11):
        entrada = tabla_doble.tabla[i]
        if entrada.ocupada:
            print(f"{i}- [ ({entrada.clave}) ]")
        else:
            print(f"{i}- [ ]")
    print("}")
    
    print(f"Numero total de colisiones al insertar los elementos: {colisiones_totales_doble}")
    
    for clave, _ in datos_teoria:
        resultado, colisiones = tabla_doble.buscar(clave)
        print(f"Al buscar: {clave}, encuentro: {clave}, colisiones: {colisiones}")
    
    resultado, colisiones = tabla_doble.buscar("CARLOS")
    print(f"No encuentro: CARLOS, colisiones: {colisiones}")

test_teoria()


# EJERCICIOS 3 Y 4
# Leer datos del archivo
def leer_sinonimos(nombre="sinonimos.txt"):
    datos = []
    with open(nombre, "r", encoding="utf-8") as f:
        for linea in f:
            clave, sinonimos = linea.strip().split("\t", 1)
            datos.append((clave, sinonimos))
    return datos

datos = leer_sinonimos()

# Configuraciones de tablas según el enunciado CON COTAS PERSONALIZADAS
configuraciones = [
    # (Nombre, Tipo, Tamaño, Dispersión, Resolución, [Cota1, Cota2, Cota3])
    ("TablaAbierta dispersionA", "abierta", 19069, dispersionA, None, [0.8, 1.0, 1.2]),
    ("TablaAbierta dispersionB", "abierta", 19069, dispersionB, None, [0.7, 1.0, 1.3]),
    ("TablaCerrada dispersionA exploracion_lineal", "cerrada", 38197, dispersionA, exploracion_lineal, [0.9, 1.0, 1.1]),
    ("TablaCerrada dispersionB exploracion_lineal", "cerrada", 38197, dispersionB, exploracion_lineal, [0.8, 1.0, 1.2]),
    ("TablaCerrada dispersionA exploracion_cuadratica", "cerrada", 38197, dispersionA, exploracion_cuadratica, [0.6, 1.0, 1.4]),
    ("TablaCerrada dispersionB exploracion_cuadratica", "cerrada", 38197, dispersionB, exploracion_cuadratica, [0.7, 1.0, 1.3]),
    ("TablaCerrada dispersionA exploracion_doble", "cerrada", 38197, dispersionA, exploracion_doble, [0.8, 1.0, 1.2]),
    ("TablaCerrada dispersionB exploracion_doble", "cerrada", 38197, dispersionB, exploracion_doble, [0.9, 1.0, 1.1]),
]

# EJERCICIO 3: Insertar todos los datos y contar colisiones totales
print("\n" + "=" * 60)
print("EJERCICIO 3: COLISIONES TOTALES AL INSERTAR")
print("=" * 60)

resultados_insertar = {}

for nombre, tipo, tam, disp, resol, cotas in configuraciones:
    print(f"\n*** {nombre}")
    
    if tipo == "abierta":
        tabla = TablaAbierta(tam, disp)
    else:
        tabla = TablaCerrada(tam, disp, resol)
    
    colisiones_totales = 0
    elementos_insertados = 0
    
    print(f"Insertando {len(datos)} elementos...", end=" ")
    
    for clave, sinonimos in datos:
        colisiones = tabla.insertar(clave, sinonimos)
        colisiones_totales += colisiones
        if colisiones >= 0:  # Si se insertó (no era duplicado)
            elementos_insertados += 1
    
    print(f"Elementos insertados: {elementos_insertados}")
    print(f"Número total de colisiones: {colisiones_totales}")
    
    resultados_insertar[nombre] = {
        'tabla': tabla,
        'colisiones_totales': colisiones_totales,
        'elementos_insertados': elementos_insertados,
        'cotas': cotas  # Guardamos las cotas para el ejercicio 4
    }

# EJERCICIO 4: Complejidad computacional de la búsqueda
print("\n" + "=" * 60)
print("EJERCICIO 4: COMPLEJIDAD COMPUTACIONAL DE BÚSQUEDA")
print("=" * 60)

# Tamaños para el análisis (similar a P3)
n_values = [125, 250, 500, 1000, 2000, 4000, 8000, 16000]

for config in configuraciones:
    nombre, tipo, tam, disp, resol, cotas = config
    
    print(f"\n*** {nombre}")
    
    # Obtener la tabla ya poblada y las cotas
    tabla_info = resultados_insertar[nombre]
    tabla = tabla_info['tabla']
    cotas_tabla = tabla_info['cotas']
    
    print("Buscando n elementos...")
    
    # Construir cabecera dinámica basada en las cotas
    header = f"{'n':>8} {'t(n)':>12}"
    for cota in cotas_tabla:
        header += f" {'t(n)/n^' + str(cota):>15}"
    header += f" {'Colisiones':>12}"
    print(header)
    print("-" * (8 + 12 + 15 * len(cotas_tabla) + 12 + 10))
    
    tiempos = []
    colisiones_totales_busqueda = []
    asterisco_list = []
    
    for n in n_values:
        if n > len(datos):
            break
            
        # Seleccionar n claves al azar (como indica el consejo)
        claves_a_buscar = random.sample(datos, n)
        
        # Medir tiempo de búsqueda
        def buscar_n_elementos(tabla_obj, claves):
            colisiones_totales = 0
            for clave, _ in claves:
                _, colisiones = tabla_obj.buscar(clave)
                colisiones_totales += colisiones
            return colisiones_totales
        
        # Medición de tiempo similar a P3
        t_directo = microsegundos()
        colisiones_n = buscar_n_elementos(tabla, claves_a_buscar)
        t_directo = microsegundos() - t_directo
        
        asterisco = False
        tiempo_final = t_directo
        
        if t_directo < 1000:  # Umbral de confianza
            asterisco = True
            k = 10000  # Número de iteraciones
            
            # Medir K ejecuciones completas
            t1 = microsegundos()
            for _ in range(k):
                buscar_n_elementos(tabla, claves_a_buscar)
            t2 = microsegundos()
            t_total = t2 - t1
            
            tiempo_final = t_total / k
        
        tiempos.append(tiempo_final)
        colisiones_totales_busqueda.append(colisiones_n)
        asterisco_list.append(asterisco)
        
        # Calcular ratios para análisis de complejidad usando las cotas específicas
        t = tiempo_final
        ratios = []
        for cota in cotas_tabla:
            ratio = t / (n ** cota) if n > 0 else 0
            ratios.append(ratio)
        
        # Imprimir fila
        n_str = f"*{n}" if asterisco else str(n)
        fila = f"{n_str:>8} {t:>12.4f}"
        for ratio in ratios:
            fila += f" {ratio:>15.8f}"
        fila += f" {colisiones_n:>12}"
        print(fila)
    
    print("-" * (8 + 12 + 15 * len(cotas_tabla) + 12 + 10))
    
    # Análisis de complejidad con las cotas personalizadas
    print("\nAnálisis de complejidad:")
    if len(tiempos) >= 3:
        # Verificar para cada cota cuál se mantiene más constante
        mejor_cota = None
        mejor_variacion = float('inf')
        
        for i, cota in enumerate(cotas_tabla):
            ratios = [tiempos[j] / (n_values[j] ** cota) for j in range(len(tiempos))]
            # Filtrar valores cero para evitar división por cero
            ratios_no_cero = [r for r in ratios if r > 0]
            if ratios_no_cero:
                variacion = max(ratios_no_cero) / min(ratios_no_cero)
            else:
                variacion = float('inf')
            
            print(f"  Cota n^{cota}: variación = {variacion:.2f}x")
            
            if variacion < mejor_variacion:
                mejor_variacion = variacion
                mejor_cota = cota
        
        if mejor_variacion < 5:  # Umbral empírico para "constante"
            print(f"✓ Mejor ajuste: O(n^{mejor_cota}) (variación: {mejor_variacion:.2f}x)")
            if mejor_cota == 1.0:
                print("✓ Se obtiene O(n) como se esperaba para búsquedas en tablas hash")
            else:
                print(f"✗ No se obtiene O(n), mejor ajuste es O(n^{mejor_cota})")
        else:
            print(f"✗ No se observa un claro patrón O(n^k)")
    
